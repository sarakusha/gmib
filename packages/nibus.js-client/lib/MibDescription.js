"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MibDescriptionV = exports.NibusParityV = exports.NibusBaudRateV = exports.FindKindV = void 0;

require("source-map-support/register");

var t = _interopRequireWildcard(require("io-ts"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/*
 * @license
 * Copyright (c) 2019. OOO Nata-Info
 * @author Andrei Sarakeev <avs@nata-info.ru>
 *
 * This file is part of the "@nata" project.
 * For the full copyright and license information, please view
 * the EULA file that was distributed with this source code.
 */

/* tslint:disable:variable-name */
const FindKindV = t.keyof({
  sarp: null,
  version: null
}, 'FindKind');
exports.FindKindV = FindKindV;
const NibusBaudRateV = t.union([t.literal(115200), t.literal(57600), t.literal(28800)], 'NibusBaudRate');
exports.NibusBaudRateV = NibusBaudRateV;
const NibusParityV = t.keyof({
  none: null,
  even: null,
  mark: null
}, 'NibusParity');
exports.NibusParityV = NibusParityV;
const MibDescriptionV = t.recursion('MibDescriptionV', () => t.partial({
  type: t.number,
  mib: t.string,
  link: t.boolean,
  baudRate: NibusBaudRateV,
  parity: NibusParityV,
  category: t.string,
  find: FindKindV,
  disableBatchReading: t.boolean,
  select: t.array(MibDescriptionV),
  win32: t.union([MibDescriptionV, t.undefined])
}));
exports.MibDescriptionV = MibDescriptionV;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NaWJEZXNjcmlwdGlvbi50cyJdLCJuYW1lcyI6WyJGaW5kS2luZFYiLCJ0Iiwia2V5b2YiLCJzYXJwIiwidmVyc2lvbiIsIk5pYnVzQmF1ZFJhdGVWIiwidW5pb24iLCJsaXRlcmFsIiwiTmlidXNQYXJpdHlWIiwibm9uZSIsImV2ZW4iLCJtYXJrIiwiTWliRGVzY3JpcHRpb25WIiwicmVjdXJzaW9uIiwicGFydGlhbCIsInR5cGUiLCJudW1iZXIiLCJtaWIiLCJzdHJpbmciLCJsaW5rIiwiYm9vbGVhbiIsImJhdWRSYXRlIiwicGFyaXR5IiwiY2F0ZWdvcnkiLCJmaW5kIiwiZGlzYWJsZUJhdGNoUmVhZGluZyIsInNlbGVjdCIsImFycmF5Iiwid2luMzIiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQVVBOzs7O0FBVkE7Ozs7Ozs7Ozs7QUFTQTtBQUdPLE1BQU1BLFNBQVMsR0FBR0MsQ0FBQyxDQUFDQyxLQUFGLENBQVE7QUFDL0JDLEVBQUFBLElBQUksRUFBRSxJQUR5QjtBQUUvQkMsRUFBQUEsT0FBTyxFQUFFO0FBRnNCLENBQVIsRUFHdEIsVUFIc0IsQ0FBbEI7O0FBTUEsTUFBTUMsY0FBYyxHQUFHSixDQUFDLENBQUNLLEtBQUYsQ0FDNUIsQ0FBQ0wsQ0FBQyxDQUFDTSxPQUFGLENBQVUsTUFBVixDQUFELEVBQW9CTixDQUFDLENBQUNNLE9BQUYsQ0FBVSxLQUFWLENBQXBCLEVBQXNDTixDQUFDLENBQUNNLE9BQUYsQ0FBVSxLQUFWLENBQXRDLENBRDRCLEVBRTVCLGVBRjRCLENBQXZCOztBQUtBLE1BQU1DLFlBQVksR0FBR1AsQ0FBQyxDQUFDQyxLQUFGLENBQzFCO0FBQ0VPLEVBQUFBLElBQUksRUFBRSxJQURSO0FBRUVDLEVBQUFBLElBQUksRUFBRSxJQUZSO0FBR0VDLEVBQUFBLElBQUksRUFBRTtBQUhSLENBRDBCLEVBTTFCLGFBTjBCLENBQXJCOztBQVlBLE1BQU1DLGVBQXdDLEdBQUdYLENBQUMsQ0FBQ1ksU0FBRixDQUFZLGlCQUFaLEVBQStCLE1BQ3JGWixDQUFDLENBQUNhLE9BQUYsQ0FBVTtBQUNSQyxFQUFBQSxJQUFJLEVBQUVkLENBQUMsQ0FBQ2UsTUFEQTtBQUVSQyxFQUFBQSxHQUFHLEVBQUVoQixDQUFDLENBQUNpQixNQUZDO0FBR1JDLEVBQUFBLElBQUksRUFBRWxCLENBQUMsQ0FBQ21CLE9BSEE7QUFJUkMsRUFBQUEsUUFBUSxFQUFFaEIsY0FKRjtBQUtSaUIsRUFBQUEsTUFBTSxFQUFFZCxZQUxBO0FBTVJlLEVBQUFBLFFBQVEsRUFBRXRCLENBQUMsQ0FBQ2lCLE1BTko7QUFPUk0sRUFBQUEsSUFBSSxFQUFFeEIsU0FQRTtBQVFSeUIsRUFBQUEsbUJBQW1CLEVBQUV4QixDQUFDLENBQUNtQixPQVJmO0FBU1JNLEVBQUFBLE1BQU0sRUFBRXpCLENBQUMsQ0FBQzBCLEtBQUYsQ0FBUWYsZUFBUixDQVRBO0FBVVJnQixFQUFBQSxLQUFLLEVBQUUzQixDQUFDLENBQUNLLEtBQUYsQ0FBUSxDQUFDTSxlQUFELEVBQWtCWCxDQUFDLENBQUM0QixTQUFwQixDQUFSO0FBVkMsQ0FBVixDQURzRCxDQUFqRCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE5LiBPT08gTmF0YS1JbmZvXG4gKiBAYXV0aG9yIEFuZHJlaSBTYXJha2VldiA8YXZzQG5hdGEtaW5mby5ydT5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgXCJAbmF0YVwiIHByb2plY3QuXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2Ugdmlld1xuICogdGhlIEVVTEEgZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWUgKi9cbmltcG9ydCAqIGFzIHQgZnJvbSAnaW8tdHMnO1xuXG5leHBvcnQgY29uc3QgRmluZEtpbmRWID0gdC5rZXlvZih7XG4gIHNhcnA6IG51bGwsXG4gIHZlcnNpb246IG51bGwsXG59LCAnRmluZEtpbmQnKTtcbmV4cG9ydCB0eXBlIEZpbmRLaW5kID0gdC5UeXBlT2Y8dHlwZW9mIEZpbmRLaW5kVj47XG5cbmV4cG9ydCBjb25zdCBOaWJ1c0JhdWRSYXRlViA9IHQudW5pb24oXG4gIFt0LmxpdGVyYWwoMTE1MjAwKSwgdC5saXRlcmFsKDU3NjAwKSwgdC5saXRlcmFsKDI4ODAwKV0sXG4gICdOaWJ1c0JhdWRSYXRlJyxcbik7XG5cbmV4cG9ydCBjb25zdCBOaWJ1c1Bhcml0eVYgPSB0LmtleW9mKFxuICB7XG4gICAgbm9uZTogbnVsbCxcbiAgICBldmVuOiBudWxsLFxuICAgIG1hcms6IG51bGwsXG4gIH0sXG4gICdOaWJ1c1Bhcml0eScsXG4pO1xuXG5leHBvcnQgdHlwZSBOaWJ1c0JhdWRSYXRlID0gdC5UeXBlT2Y8dHlwZW9mIE5pYnVzQmF1ZFJhdGVWPjtcbmV4cG9ydCB0eXBlIE5pYnVzUGFyaXR5ID0gdC5UeXBlT2Y8dHlwZW9mIE5pYnVzUGFyaXR5Vj47XG5cbmV4cG9ydCBjb25zdCBNaWJEZXNjcmlwdGlvblY6IHQuVHlwZTxJTWliRGVzY3JpcHRpb24+ID0gdC5yZWN1cnNpb24oJ01pYkRlc2NyaXB0aW9uVicsICgpID0+XG4gIHQucGFydGlhbCh7XG4gICAgdHlwZTogdC5udW1iZXIsXG4gICAgbWliOiB0LnN0cmluZyxcbiAgICBsaW5rOiB0LmJvb2xlYW4sXG4gICAgYmF1ZFJhdGU6IE5pYnVzQmF1ZFJhdGVWLFxuICAgIHBhcml0eTogTmlidXNQYXJpdHlWLFxuICAgIGNhdGVnb3J5OiB0LnN0cmluZyxcbiAgICBmaW5kOiBGaW5kS2luZFYsXG4gICAgZGlzYWJsZUJhdGNoUmVhZGluZzogdC5ib29sZWFuLFxuICAgIHNlbGVjdDogdC5hcnJheShNaWJEZXNjcmlwdGlvblYpLFxuICAgIHdpbjMyOiB0LnVuaW9uKFtNaWJEZXNjcmlwdGlvblYsIHQudW5kZWZpbmVkXSksXG4gIH0pLFxuKTtcblxuZXhwb3J0IGludGVyZmFjZSBJTWliRGVzY3JpcHRpb24ge1xuICB0eXBlPzogbnVtYmVyO1xuICBtaWI/OiBzdHJpbmc7XG4gIGxpbms/OiBib29sZWFuO1xuICBiYXVkUmF0ZT86IE5pYnVzQmF1ZFJhdGU7XG4gIHBhcml0eT86IE5pYnVzUGFyaXR5O1xuICBjYXRlZ29yeT86IHN0cmluZztcbiAgZmluZD86IEZpbmRLaW5kO1xuICBkaXNhYmxlQmF0Y2hSZWFkaW5nPzogYm9vbGVhbjtcbiAgc2VsZWN0PzogSU1pYkRlc2NyaXB0aW9uW107XG4gIHdpbjMyPzogSU1pYkRlc2NyaXB0aW9uO1xufVxuIl19