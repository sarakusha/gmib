"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AddressType = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MAC_LENGTH = 6;

const isHex = str => /^(?:0X[0-9A-F]+)|(?:[0-9]*[A-F]+)/i.test(str);

const parseHex = str => parseInt(str, 16);

let AddressType;
exports.AddressType = AddressType;

(function (AddressType) {
  AddressType["broadcast"] = "broadcast";
  AddressType["empty"] = "empty";
  AddressType[AddressType["mac"] = 0] = "mac";
  AddressType[AddressType["net"] = 1] = "net";
  AddressType[AddressType["group"] = 2] = "group";
})(AddressType || (exports.AddressType = AddressType = {}));

const isEmpty = array => _lodash.default.every(array, b => b === 0);

const isBroadcast = array => _lodash.default.every(array, b => b === 255);

class Address {
  static toAddress(address) {
    if (address == null) {
      return address;
    }

    return address instanceof Address ? address : new Address(address);
  }

  static read(type, buffer, offset = 0) {
    if (buffer.length - offset < MAC_LENGTH) {
      throw new Error('Invalid buffer length');
    }

    switch (type) {
      case AddressType.mac:
        {
          const mac = buffer.slice(offset, offset + MAC_LENGTH);
          return new Address(mac);
        }

      case AddressType.net:
        {
          const net = [buffer.readUInt16LE(offset), buffer.readUInt8(offset + 2), buffer.readUInt16LE(offset + 3)];
          return new Address(net.join('.'));
        }

      case AddressType.group:
        {
          const group = [buffer.readUInt16LE(offset), buffer.readUInt8(offset + 2)];
          return new Address(group.join('.'));
        }

      default:
        throw new Error(`Invalid address type ${type}`);
    }
  }

  constructor(address = '') {
    _defineProperty(this, "type", void 0);

    _defineProperty(this, "domain", void 0);

    _defineProperty(this, "group", void 0);

    _defineProperty(this, "subnet", void 0);

    _defineProperty(this, "device", void 0);

    _defineProperty(this, "mac", void 0);

    _defineProperty(this, "raw", void 0);

    let pos = 0;

    if (typeof address === 'string') {
      this.raw = Buffer.alloc(MAC_LENGTH);

      switch (address) {
        case '':
          this.type = AddressType.empty;
          break;

        case 'broadcast':
          this.type = AddressType.broadcast;
          this.raw.fill(255);
          break;

        case 'auto':
          {
            this.raw.fill(0xFE, 0, 2);
            this.raw.writeUInt32BE(Address.autocount, 2);
            this.type = AddressType.mac;
            Address.autocount += 1;
            break;
          }

        default:
          if (!/^[0-9A-FX.:]+$/i.test(address)) {
            throw new Error('Invalid address');
          }

          if (address.indexOf('.') !== -1) {
            const parts = address.split('.', 4);
            const radix = _lodash.default.some(parts, isHex) ? 16 : 10;

            switch (parts.length) {
              case 2:
                {
                  const [domain, group] = parts;
                  this.domain = parseInt(domain, radix);
                  this.group = parseInt(group, radix);
                  this.type = AddressType.group;
                  pos = this.raw.writeUInt16LE(this.domain || 0, 0);
                  this.raw.writeUInt8(this.group || 0, pos);
                  break;
                }

              case 3:
                {
                  const [domain, subnet, device] = parts;
                  this.domain = parseInt(domain, radix);
                  this.subnet = parseInt(subnet, radix);
                  this.device = parseInt(device, radix);
                  this.type = AddressType.net;
                  pos = this.raw.writeUInt16LE(this.domain || 0, 0);
                  pos = this.raw.writeUInt8(this.subnet || 0, pos);
                  this.raw.writeUInt16LE(this.device || 0, pos);
                  break;
                }

              default:
                throw new Error('Invalid address');
            }
          } else {
            // MAC
            const [left, right, rest] = address.split('::', 3);

            if (rest) {
              throw new Error('Invalid address');
            }

            const lefts = left ? left.split(':') : [];
            const rights = right ? right.split(':') : [];
            let len = lefts.length + rights.length;

            if (len > MAC_LENGTH) {
              throw new Error('Invalid address');
            }

            const mac = lefts.map(parseHex);

            while (len < MAC_LENGTH) {
              mac.push(0);
              len += 1;
            }

            mac.push(...rights.map(parseHex));

            if (_lodash.default.some(mac, byte => byte < 0 || byte > 255)) {
              throw new Error('Invalid address');
            }

            this.mac = Buffer.from(mac);
            this.raw = this.mac;

            if (isEmpty(mac)) {
              this.type = AddressType.empty;
            } else if (isBroadcast(mac)) {
              this.type = AddressType.broadcast;
            } else {
              this.type = AddressType.mac;
            }
          }

      }
    } else if ((Array.isArray(address) || address instanceof Uint8Array) && address.length === MAC_LENGTH) {
      this.mac = Buffer.from(address);
      this.raw = this.mac;

      if (isEmpty(address)) {
        this.type = AddressType.empty;
      } else if (isBroadcast(address)) {
        this.type = AddressType.broadcast;
      } else {
        this.type = AddressType.mac;
      }
    } else if (address instanceof Address) {
      this.raw = Buffer.from(address.raw);
      this.type = address.type;

      if (address.mac) {
        this.mac = this.raw;
      }

      this.domain = address.domain;
      this.group = address.group;
      this.subnet = address.subnet;
      this.device = address.device;
    } else {
      throw new Error('Invalid address');
    }

    const value = this.raw;
    Object.defineProperty(this, 'raw', {
      value,
      enumerable: false
    });
    Object.freeze(this);
  }

  get isEmpty() {
    return this.type === AddressType.empty;
  }

  get isBroadcast() {
    return this.type === AddressType.broadcast;
  }

  get rawType() {
    switch (this.type) {
      case AddressType.empty:
      case AddressType.broadcast:
        return AddressType.mac;

      default:
        console.assert(0 <= this.type && this.type <= 2);
        return this.type;
    }
  }

  toString() {
    switch (this.type) {
      case AddressType.empty:
        return '::0';

      case AddressType.broadcast:
        return 'FF:FF:FF:FF:FF:FF';

      case AddressType.group:
        return `${this.domain}.${this.group}`;

      case AddressType.net:
        return `${this.domain}.${this.subnet}.${this.device}`;

      case AddressType.mac:
        {
          const mac = this.mac ? [...this.mac] : [];
          const first = mac.findIndex(b => b > 0);
          const str = [...mac.slice(first)].map(b => `0${b.toString(16)}`.slice(-2)).join(':').toUpperCase();
          return first > 0 ? `::${str}` : str;
        }

      default:
        throw new Error('Invalid address type');
    }
  }

  equals(other) {
    if (other == null) {
      return false;
    }

    const otherAddress = other instanceof Address ? other : new Address(other);
    return otherAddress.toString() === this.toString();
  }

}

exports.default = Address;

_defineProperty(Address, "autocount", 1);

_defineProperty(Address, "empty", new Address());

_defineProperty(Address, "broadcast", new Address('broadcast'));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9BZGRyZXNzLnRzIl0sIm5hbWVzIjpbIk1BQ19MRU5HVEgiLCJpc0hleCIsInN0ciIsInRlc3QiLCJwYXJzZUhleCIsInBhcnNlSW50IiwiQWRkcmVzc1R5cGUiLCJpc0VtcHR5IiwiYXJyYXkiLCJfIiwiZXZlcnkiLCJiIiwiaXNCcm9hZGNhc3QiLCJBZGRyZXNzIiwidG9BZGRyZXNzIiwiYWRkcmVzcyIsInJlYWQiLCJ0eXBlIiwiYnVmZmVyIiwib2Zmc2V0IiwibGVuZ3RoIiwiRXJyb3IiLCJtYWMiLCJzbGljZSIsIm5ldCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50OCIsImpvaW4iLCJncm91cCIsImNvbnN0cnVjdG9yIiwicG9zIiwicmF3IiwiQnVmZmVyIiwiYWxsb2MiLCJlbXB0eSIsImJyb2FkY2FzdCIsImZpbGwiLCJ3cml0ZVVJbnQzMkJFIiwiYXV0b2NvdW50IiwiaW5kZXhPZiIsInBhcnRzIiwic3BsaXQiLCJyYWRpeCIsInNvbWUiLCJkb21haW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50OCIsInN1Ym5ldCIsImRldmljZSIsImxlZnQiLCJyaWdodCIsInJlc3QiLCJsZWZ0cyIsInJpZ2h0cyIsImxlbiIsIm1hcCIsInB1c2giLCJieXRlIiwiZnJvbSIsIkFycmF5IiwiaXNBcnJheSIsIlVpbnQ4QXJyYXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsInJhd1R5cGUiLCJjb25zb2xlIiwiYXNzZXJ0IiwidG9TdHJpbmciLCJmaXJzdCIsImZpbmRJbmRleCIsInRvVXBwZXJDYXNlIiwiZXF1YWxzIiwib3RoZXIiLCJvdGhlckFkZHJlc3MiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQVNBOzs7Ozs7QUFFQSxNQUFNQSxVQUFVLEdBQUcsQ0FBbkI7O0FBRUEsTUFBTUMsS0FBSyxHQUFJQyxHQUFELElBQWlCLHFDQUFxQ0MsSUFBckMsQ0FBMENELEdBQTFDLENBQS9C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R0FBbUMsSUFBSTlELE9BQUosQ0FBWThELEtBQVosQ0FBeEQ7QUFDQSxXQUFPQyxZQUFZLENBQUNOLFFBQWIsT0FBNEIsS0FBS0EsUUFBTCxFQUFuQztBQUNEOztBQXBOMEI7Ozs7Z0JBQVJ6RCxPLGVBQ1EsQzs7Z0JBRFJBLE8sV0FFWSxJQUFJQSxPQUFKLEU7O2dCQUZaQSxPLGVBR08sSUFBSUEsT0FBSixDQUFZLFdBQVosQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE5LiBPT08gTmF0YS1JbmZvXG4gKiBAYXV0aG9yIEFuZHJlaSBTYXJha2VldiA8YXZzQG5hdGEtaW5mby5ydT5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgXCJAbmF0YVwiIHByb2plY3QuXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2Ugdmlld1xuICogdGhlIEVVTEEgZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IE1BQ19MRU5HVEggPSA2O1xuXG5jb25zdCBpc0hleCA9IChzdHI6IHN0cmluZykgPT4gL14oPzowWFswLTlBLUZdKyl8KD86WzAtOV0qW0EtRl0rKS9pLnRlc3Qoc3RyKTtcbmNvbnN0IHBhcnNlSGV4ID0gKHN0cjogc3RyaW5nKSA9PiBwYXJzZUludChzdHIsIDE2KTtcblxuZXhwb3J0IGVudW0gQWRkcmVzc1R5cGUge1xuICBicm9hZGNhc3QgPSAnYnJvYWRjYXN0JyxcbiAgZW1wdHkgPSAnZW1wdHknLFxuICBtYWMgPSAwLFxuICBuZXQgPSAxLFxuICBncm91cCA9IDIsXG59XG5cbmNvbnN0IGlzRW1wdHkgPSAoYXJyYXk6IG51bWJlcltdIHwgVWludDhBcnJheSkgPT4gXy5ldmVyeShhcnJheSwgYiA9PiBiID09PSAwKTtcbmNvbnN0IGlzQnJvYWRjYXN0ID0gKGFycmF5OiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkpID0+IF8uZXZlcnkoYXJyYXksIGIgPT4gYiA9PT0gMjU1KTtcblxuZXhwb3J0IHR5cGUgQWRkcmVzc1BhcmFtID0gc3RyaW5nIHwgQnVmZmVyIHwgbnVtYmVyW10gfCBVaW50OEFycmF5IHwgQWRkcmVzcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRkcmVzcyB7XG4gIHByaXZhdGUgc3RhdGljIGF1dG9jb3VudCA9IDE7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZW1wdHkgPSBuZXcgQWRkcmVzcygpO1xuICBwdWJsaWMgc3RhdGljIGJyb2FkY2FzdCA9IG5ldyBBZGRyZXNzKCdicm9hZGNhc3QnKTtcblxuICBwdWJsaWMgc3RhdGljIHRvQWRkcmVzcyhhZGRyZXNzPzogQWRkcmVzc1BhcmFtIHwgbnVsbCkge1xuICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcyBpbnN0YW5jZW9mIEFkZHJlc3MgPyBhZGRyZXNzISA6IG5ldyBBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyByZWFkKHR5cGU6IEFkZHJlc3NUeXBlLCBidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIgPSAwKTogQWRkcmVzcyB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQgPCBNQUNfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQWRkcmVzc1R5cGUubWFjOiB7XG4gICAgICAgIGNvbnN0IG1hYyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIE1BQ19MRU5HVEgpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MobWFjKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQWRkcmVzc1R5cGUubmV0OiB7XG4gICAgICAgIGNvbnN0IG5ldCA9IFtcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCksXG4gICAgICAgICAgYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAyKSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCArIDMpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MobmV0LmpvaW4oJy4nKSk7XG4gICAgICB9XG4gICAgICBjYXNlIEFkZHJlc3NUeXBlLmdyb3VwOiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gW1xuICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0KSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCArIDIpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoZ3JvdXAuam9pbignLicpKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhZGRyZXNzIHR5cGUgJHt0eXBlfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWFkb25seSB0eXBlOiBBZGRyZXNzVHlwZTtcbiAgcHVibGljIHJlYWRvbmx5IGRvbWFpbj86IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGdyb3VwPzogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgc3VibmV0PzogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgZGV2aWNlPzogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgbWFjPzogQnVmZmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgcmF3OiBCdWZmZXI7XG5cbiAgY29uc3RydWN0b3IoYWRkcmVzczogQWRkcmVzc1BhcmFtID0gJycpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJhdyA9IEJ1ZmZlci5hbGxvYyhNQUNfTEVOR1RIKTtcbiAgICAgIHN3aXRjaCAoYWRkcmVzcykge1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgIHRoaXMudHlwZSA9IEFkZHJlc3NUeXBlLmVtcHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdicm9hZGNhc3QnOlxuICAgICAgICAgIHRoaXMudHlwZSA9IEFkZHJlc3NUeXBlLmJyb2FkY2FzdDtcbiAgICAgICAgICB0aGlzLnJhdy5maWxsKDI1NSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2F1dG8nOiB7XG4gICAgICAgICAgdGhpcy5yYXcuZmlsbCgweEZFLCAwLCAyKTtcbiAgICAgICAgICB0aGlzLnJhdy53cml0ZVVJbnQzMkJFKEFkZHJlc3MuYXV0b2NvdW50LCAyKTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBBZGRyZXNzVHlwZS5tYWM7XG4gICAgICAgICAgQWRkcmVzcy5hdXRvY291bnQgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghL15bMC05QS1GWC46XSskL2kudGVzdChhZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFkZHJlc3MuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhZGRyZXNzLnNwbGl0KCcuJywgNCk7XG4gICAgICAgICAgICBjb25zdCByYWRpeCA9IF8uc29tZShwYXJ0cywgaXNIZXgpID8gMTYgOiAxMDtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtkb21haW4sIGdyb3VwXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tYWluID0gcGFyc2VJbnQoZG9tYWluLCByYWRpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cCA9IHBhcnNlSW50KGdyb3VwLCByYWRpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gQWRkcmVzc1R5cGUuZ3JvdXA7XG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5yYXcud3JpdGVVSW50MTZMRSh0aGlzLmRvbWFpbiB8fCAwLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdy53cml0ZVVJbnQ4KHRoaXMuZ3JvdXAgfHwgMCwgcG9zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZG9tYWluLCBzdWJuZXQsIGRldmljZV0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICB0aGlzLmRvbWFpbiA9IHBhcnNlSW50KGRvbWFpbiwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibmV0ID0gcGFyc2VJbnQoc3VibmV0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXZpY2UgPSBwYXJzZUludChkZXZpY2UsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBBZGRyZXNzVHlwZS5uZXQ7XG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5yYXcud3JpdGVVSW50MTZMRSh0aGlzLmRvbWFpbiB8fCAwLCAwKTtcbiAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLnJhdy53cml0ZVVJbnQ4KHRoaXMuc3VibmV0IHx8IDAsIHBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXcud3JpdGVVSW50MTZMRSh0aGlzLmRldmljZSB8fCAwLCBwb3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTUFDXG4gICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHQsIHJlc3RdID0gYWRkcmVzcy5zcGxpdCgnOjonLCAzKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZWZ0cyA9IGxlZnQgPyBsZWZ0LnNwbGl0KCc6JykgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0cyA9IHJpZ2h0ID8gcmlnaHQuc3BsaXQoJzonKSA6IFtdO1xuICAgICAgICAgICAgbGV0IGxlbiA9IGxlZnRzLmxlbmd0aCArIHJpZ2h0cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gTUFDX0xFTkdUSCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFjID0gbGVmdHMubWFwKHBhcnNlSGV4KTtcbiAgICAgICAgICAgIHdoaWxlIChsZW4gPCBNQUNfTEVOR1RIKSB7XG4gICAgICAgICAgICAgIG1hYy5wdXNoKDApO1xuICAgICAgICAgICAgICBsZW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hYy5wdXNoKC4uLnJpZ2h0cy5tYXAocGFyc2VIZXgpKTtcbiAgICAgICAgICAgIGlmIChfLnNvbWUobWFjLCBieXRlID0+IGJ5dGUgPCAwIHx8IGJ5dGUgPiAyNTUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hYyA9IEJ1ZmZlci5mcm9tKG1hYyk7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHRoaXMubWFjO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkobWFjKSkge1xuICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBBZGRyZXNzVHlwZS5lbXB0eTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNCcm9hZGNhc3QobWFjKSkge1xuICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBBZGRyZXNzVHlwZS5icm9hZGNhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBBZGRyZXNzVHlwZS5tYWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKEFycmF5LmlzQXJyYXkoYWRkcmVzcykgfHwgYWRkcmVzcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAmJiBhZGRyZXNzLmxlbmd0aCA9PT0gTUFDX0xFTkdUSCkge1xuICAgICAgdGhpcy5tYWMgPSBCdWZmZXIuZnJvbShhZGRyZXNzIGFzIGFueVtdKTtcbiAgICAgIHRoaXMucmF3ID0gdGhpcy5tYWMhO1xuICAgICAgaWYgKGlzRW1wdHkoYWRkcmVzcykpIHtcbiAgICAgICAgdGhpcy50eXBlID0gQWRkcmVzc1R5cGUuZW1wdHk7XG4gICAgICB9IGVsc2UgaWYgKGlzQnJvYWRjYXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IEFkZHJlc3NUeXBlLmJyb2FkY2FzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHlwZSA9IEFkZHJlc3NUeXBlLm1hYztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBBZGRyZXNzKSB7XG4gICAgICB0aGlzLnJhdyA9IEJ1ZmZlci5mcm9tKGFkZHJlc3MucmF3KTtcbiAgICAgIHRoaXMudHlwZSA9IGFkZHJlc3MudHlwZTtcbiAgICAgIGlmIChhZGRyZXNzLm1hYykge1xuICAgICAgICB0aGlzLm1hYyA9IHRoaXMucmF3O1xuICAgICAgfVxuICAgICAgdGhpcy5kb21haW4gPSBhZGRyZXNzLmRvbWFpbjtcbiAgICAgIHRoaXMuZ3JvdXAgPSBhZGRyZXNzLmdyb3VwO1xuICAgICAgdGhpcy5zdWJuZXQgPSBhZGRyZXNzLnN1Ym5ldDtcbiAgICAgIHRoaXMuZGV2aWNlID0gYWRkcmVzcy5kZXZpY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yYXc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyYXcnLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzVHlwZS5lbXB0eTtcbiAgfVxuXG4gIGdldCBpc0Jyb2FkY2FzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzVHlwZS5icm9hZGNhc3Q7XG4gIH1cblxuICBnZXQgcmF3VHlwZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIEFkZHJlc3NUeXBlLmVtcHR5OlxuICAgICAgY2FzZSBBZGRyZXNzVHlwZS5icm9hZGNhc3Q6XG4gICAgICAgIHJldHVybiBBZGRyZXNzVHlwZS5tYWM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmFzc2VydCgwIDw9IHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgPD0gMik7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIEFkZHJlc3NUeXBlLmVtcHR5OlxuICAgICAgICByZXR1cm4gJzo6MCc7XG4gICAgICBjYXNlIEFkZHJlc3NUeXBlLmJyb2FkY2FzdDpcbiAgICAgICAgcmV0dXJuICdGRjpGRjpGRjpGRjpGRjpGRic7XG4gICAgICBjYXNlIEFkZHJlc3NUeXBlLmdyb3VwOlxuICAgICAgICByZXR1cm4gYCR7dGhpcy5kb21haW59LiR7dGhpcy5ncm91cH1gO1xuICAgICAgY2FzZSBBZGRyZXNzVHlwZS5uZXQ6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmRvbWFpbn0uJHt0aGlzLnN1Ym5ldH0uJHt0aGlzLmRldmljZX1gO1xuICAgICAgY2FzZSBBZGRyZXNzVHlwZS5tYWM6IHtcbiAgICAgICAgY29uc3QgbWFjID0gdGhpcy5tYWMgPyBbLi4udGhpcy5tYWNdIDogW107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gbWFjLmZpbmRJbmRleChiID0+IGIgPiAwKTtcbiAgICAgICAgY29uc3Qgc3RyID0gWy4uLm1hYy5zbGljZShmaXJzdCldXG4gICAgICAgICAgLm1hcChiID0+IGAwJHtiLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSlcbiAgICAgICAgICAuam9pbignOicpXG4gICAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBmaXJzdCA+IDAgPyBgOjoke3N0cn1gIDogc3RyO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdHlwZScpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBlcXVhbHMob3RoZXI/OiBzdHJpbmcgfCBudW1iZXJbXSB8IEJ1ZmZlciB8IEFkZHJlc3MgfCBudWxsKTogYm9vbGVhbiB7XG4gICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJBZGRyZXNzID0gb3RoZXIgaW5zdGFuY2VvZiBBZGRyZXNzID8gb3RoZXIgOiBuZXcgQWRkcmVzcyhvdGhlcik7XG4gICAgcmV0dXJuIG90aGVyQWRkcmVzcy50b1N0cmluZygpID09PSB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbiJdfQ==