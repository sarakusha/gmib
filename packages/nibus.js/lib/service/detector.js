"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _events = require("events");

var _fs = _interopRequireDefault(require("fs"));

var _PathReporter = require("io-ts/lib/PathReporter");

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _serialport = _interopRequireDefault(require("serialport"));

var _usbDetection = _interopRequireDefault(require("usb-detection"));

var _KnownPorts = require("@nata/nibus.js-client/lib/session/KnownPorts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * @license
 * Copyright (c) 2019. Nata-Info
 * @author Andrei Sarakeev <avs@nata-info.ru>
 *
 * This file is part of the "@nata" project.
 * For the full copyright and license information, please view
 * the EULA file that was distributed with this source code.
 */

/* tslint:disable:variable-name */
// let usbDetection: typeof UsbDetection;
const debug = (0, _debug.default)('nibus:detector');

const detectionPath = _path.default.resolve(__dirname, '../../detection.yml');

let knownPorts = Promise.resolve([]);

const loadDetection = () => {
  try {
    const data = _fs.default.readFileSync(detectionPath, 'utf8');

    const result = _jsYaml.default.safeLoad(data);

    Object.keys(result.mibCategories).forEach(category => {
      const desc = result.mibCategories[category];
      desc.category = category;

      if (Array.isArray(desc.select)) {
        desc.select = desc.select.map(cat => result.mibCategories[cat] || cat);
      }
    });
    return result;
  } catch (err) {
    debug(`Error: failed to read file ${detectionPath} (${err.message})`);
    return undefined;
  }
};

let detection = loadDetection();

function reloadDevices(lastAdded) {
  knownPorts = knownPorts.then(ports => reloadDevicesAsync(ports, lastAdded));
}

const detectionListener = (curr, prev) => {
  if (curr.mtime !== prev.mtime) {
    debug(`detection file was changed, reloading devices...`);
    detection = undefined;
    reloadDevices();
  }
};
/**
 * @fires add
 * @fires remove
 * @fires plug
 * @fires unplug
 */


class Detector extends _events.EventEmitter {
  start() {
    // usbDetection = require('usb-detection');
    _usbDetection.default.startMonitoring();

    debug(`start watching the detector file ${detectionPath}`);

    _fs.default.watchFile(detectionPath, {
      persistent: false
    }, detectionListener); // detection = loadDetection();


    reloadDevices(); // Должна быть debounce с задержкой, иначе Serial.list не определит

    _usbDetection.default.on('add', reload); // Удаление без задержки!


    _usbDetection.default.on('remove', reloadDevices);
  }

  stop() {
    _fs.default.unwatchFile(detectionPath, detectionListener);

    _usbDetection.default && _usbDetection.default.stopMonitoring();
  }

  restart() {
    if (!_usbDetection.default) return this.start();

    _usbDetection.default.stopMonitoring();

    process.nextTick(() => _usbDetection.default.startMonitoring());
  }

  async getPorts() {
    return knownPorts;
  }

  get detection() {
    return detection;
  }

}

const detector = new Detector(); // interface ISerialPort {
//   comName: string;
//   locationId?: string;
//   manufacturer?: string;
//   pnpId?: string;
//   productId: HexOrNumber;
//   serialNumber: string;
//   vendorId: HexOrNumber;
// }
// type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
//
// export interface IKnownPort extends Omit<SerialPort.PortInfo, 'productId' | 'vendorId'> {
//   device?: string;
//   productId: number;
//   vendorId: number;
//   category?: string;
// }

const getId = id => typeof id === 'string' ? parseInt(id, 16) : id;

function equals(port, device) {
  return getId(port.productId) === device.productId && getId(port.vendorId) === device.vendorId && port.serialNumber === device.serialNumber;
}

async function detectDevice(port, lastAdded) {
  let detected;

  if (lastAdded && equals(port, lastAdded)) {
    detected = lastAdded;
  } else {
    let list = await _usbDetection.default.find(getId(port.vendorId), getId(port.productId), () => {});
    const {
      serialNumber,
      manufacturer
    } = port;
    list = _lodash.default.filter(list, {
      serialNumber,
      manufacturer
    });

    if (list.length === 0) {
      debug(`Unknown device ${JSON.stringify(port)}`);
    } else if (list.length > 1) {
      debug(`can't identify device ${JSON.stringify(port)}`);
    } else {
      [detected] = list;
    }
  }

  if (detected !== undefined) {
    const {
      productId,
      vendorId,
      deviceName: device,
      deviceAddress
    } = detected;
    return { ...port,
      productId,
      vendorId,
      device,
      deviceAddress
    };
  }

  return { ...port,
    productId: getId(port.productId),
    vendorId: getId(port.vendorId)
  };
} // const loadDetection = () => new Promise<IDetection>((resolve, reject) => {
//   fs.readFile(detectionPath, 'utf8', (err, data) => {
//     if (err) {
//       reject(`Error: failed to read file ${detectionPath} (${err.message})`);
//     } else {
//       const result = yaml.safeLoad(data) as IDetection;
//       Object.keys(result.mibCategories).forEach((category) => {
//         result.mibCategories[category].category = category;
//       });
//       resolve(result);
//     }
//   });
// });


const matchCategory = port => {
  const match = detection && _lodash.default.find(detection.knownDevices, item => port.device && port.device.startsWith(item.device) && (!item.serialNumber || port.serialNumber && port.serialNumber.startsWith(item.serialNumber)) && (!item.manufacturer || port.manufacturer === item.manufacturer) && getId(item.vid) === port.vendorId && getId(item.pid) === port.productId);

  if (!match && process.platform === 'win32' && (port.productId === 0x6001 || port.productId === 0x6015) && port.vendorId === 0x0403) {
    return 'ftdi';
  }

  if (match) return _KnownPorts.CategoryV.decode(match.category).getOrElse(undefined);
};

async function reloadDevicesAsync(prevPorts, lastAdded) {
  const ports = [];

  try {
    if (detection == null) {
      detection = loadDetection();
    }

    const list = await _serialport.default.list();
    const externalPorts = list.filter(port => !!port.productId); // const prevPorts = knownPorts.splice(0);

    await externalPorts.reduce(async (promise, port) => {
      const nextPorts = await promise;

      const prev = _lodash.default.findIndex(prevPorts, {
        comName: port.comName
      });

      let device;

      if (prev !== -1) {
        [device] = prevPorts.splice(prev, 1);
        const category = matchCategory(device);

        if (category !== device.category) {
          debug(`device's category was changed ${device.category} to ${category}`);
          device.category && detector.emit('remove', device);
          device.category = _KnownPorts.CategoryV.decode(category).getOrElse(undefined);
          device.category && detector.emit('add', device);
        }
      } else {
        device = await detectDevice(port, lastAdded);
        device.category = matchCategory(device);
        /**
         * new device plugged
         * @event Detector#plug
         */

        detector.emit('plug', device); // console.log('PORT', JSON.stringify(port));

        if (device.category) {
          debug(`new device ${device.device || device.vendorId}/\
${device.category} was plugged to ${device.comName}`);
          detector.emit('add', device);
        } else {
          debug('unknown device %o was plugged', device);
        }
      }

      const validation = _KnownPorts.KnownPortV.decode(device);

      if (validation.isLeft()) {
        debug('<error>', _PathReporter.PathReporter.report(validation));
      } else {
        nextPorts.push(validation.value);
      }

      return nextPorts;
    }, Promise.resolve(ports));
    prevPorts.forEach(port => {
      /**
       * @event Detector#unplug
       */
      detector.emit('unplug', port);
      debug(`device ${port.device || port.vendorId}/\
${port.category || port.productId} was unplugged from ${port.comName}`);
      /**
       * device with category was removed
       * @event Detector#remove
       * @param {IKnownPort} device
       */

      port.category && detector.emit('remove', port);
    });
    return ports;
  } catch (err) {
    debug(`Error: reload devices was failed (${err.message || err})`);
    return ports;
  }
} // debug(`start watching the detector file ${detectionPath}`);
// fs.watchFile(detectionPath, { persistent: false }, (curr, prev) => {
//   if (curr.mtime !== prev.mtime) {
//     debug(`detection file was changed, reloading devices...`);
//     detection = undefined;
//     reloadDevices().catch();
//   }
// });
// reloadDevices();


const reload = _lodash.default.debounce(reloadDevices, 2000);

var _default = detector;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zZXJ2aWNlL2RldGVjdG9yLnRzIl0sIm5hbWVzIjpbImRlYnVnIiwiZGV0ZWN0aW9uUGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiX19kaXJuYW1lIiwia25vd25Qb3J0cyIsIlByb21pc2UiLCJsb2FkRGV0ZWN0aW9uIiwiZGF0YSIsImZzIiwicmVhZEZpbGVTeW5jIiwicmVzdWx0IiwieWFtbCIsInNhZmVMb2FkIiwiT2JqZWN0Iiwia2V5cyIsIm1pYkNhdGVnb3JpZXMiLCJmb3JFYWNoIiwiY2F0ZWdvcnkiLCJkZXNjIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VsZWN0IiwibWFwIiwiY2F0IiwiZXJyIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsImRldGVjdGlvbiIsInJlbG9hZERldmljZXMiLCJsYXN0QWRkZWQiLCJ0aGVuIiwicG9ydHMiLCJyZWxvYWREZXZpY2VzQXN5bmMiLCJkZXRlY3Rpb25MaXN0ZW5lciIsImN1cnIiLCJwcmV2IiwibXRpbWUiLCJEZXRlY3RvciIsIkV2ZW50RW1pdHRlciIsInN0YXJ0IiwidXNiRGV0ZWN0aW9uIiwic3RhcnRNb25pdG9yaW5nIiwid2F0Y2hGaWxlIiwicGVyc2lzdGVudCIsIm9uIiwicmVsb2FkIiwic3RvcCIsInVud2F0Y2hGaWxlIiwic3RvcE1vbml0b3JpbmciLCJyZXN0YXJ0IiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZ2V0UG9ydHMiLCJkZXRlY3RvciIsImdldElkIiwiaWQiLCJwYXJzZUludCIsImVxdWFscyIsInBvcnQiLCJkZXZpY2UiLCJwcm9kdWN0SWQiLCJ2ZW5kb3JJZCIsInNlcmlhbE51bWJlciIsImRldGVjdERldmljZSIsImRldGVjdGVkIiwibGlzdCIsImZpbmQiLCJtYW51ZmFjdHVyZXIiLCJfIiwiZmlsdGVyIiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsImRldmljZU5hbWUiLCJkZXZpY2VBZGRyZXNzIiwibWF0Y2hDYXRlZ29yeSIsIm1hdGNoIiwia25vd25EZXZpY2VzIiwiaXRlbSIsInN0YXJ0c1dpdGgiLCJ2aWQiLCJwaWQiLCJwbGF0Zm9ybSIsIkNhdGVnb3J5ViIsImRlY29kZSIsImdldE9yRWxzZSIsInByZXZQb3J0cyIsIlNlcmlhbFBvcnQiLCJleHRlcm5hbFBvcnRzIiwicmVkdWNlIiwicHJvbWlzZSIsIm5leHRQb3J0cyIsImZpbmRJbmRleCIsImNvbU5hbWUiLCJzcGxpY2UiLCJlbWl0IiwidmFsaWRhdGlvbiIsIktub3duUG9ydFYiLCJpc0xlZnQiLCJQYXRoUmVwb3J0ZXIiLCJyZXBvcnQiLCJwdXNoIiwidmFsdWUiLCJkZWJvdW5jZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBV0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFyQkE7Ozs7Ozs7Ozs7QUFVQTtBQW1CQTtBQUNBLE1BQU1BLEtBQUssR0FBRyxvQkFBYSxnQkFBYixDQUFkOztBQUNBLE1BQU1DLGFBQWEsR0FBR0MsY0FBS0MsT0FBTCxDQUFhQyxTQUFiLEVBQXdCLHFCQUF4QixDQUF0Qjs7QUFDQSxJQUFJQyxVQUFpQyxHQUFHQyxPQUFPLENBQUNILE9BQVIsQ0FBZ0IsRUFBaEIsQ0FBeEM7O0FBa0JBLE1BQU1JLGFBQWEsR0FBRyxNQUE4QjtBQUNsRCxNQUFJO0FBQ0YsVUFBTUMsSUFBSSxHQUFHQyxZQUFHQyxZQUFILENBQWdCVCxhQUFoQixFQUErQixNQUEvQixDQUFiOztBQUNBLFVBQU1VLE1BQU0sR0FBR0MsZ0JBQUtDLFFBQUwsQ0FBY0wsSUFBZCxDQUFmOztBQUNBTSxJQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWUosTUFBTSxDQUFDSyxhQUFuQixFQUFrQ0MsT0FBbEMsQ0FBMkNDLFFBQUQsSUFBYztBQUN0RCxZQUFNQyxJQUFJLEdBQUdSLE1BQU0sQ0FBQ0ssYUFBUCxDQUFxQkUsUUFBckIsQ0FBYjtBQUNBQyxNQUFBQSxJQUFJLENBQUNELFFBQUwsR0FBZ0JBLFFBQWhCOztBQUNBLFVBQUlFLEtBQUssQ0FB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QUFQO0FBQ0QsR0E3REQsQ0E2REUsT0FBT1AsR0FBUCxFQUFZO0FBQ1p6QixJQUFBQSxLQUFLLENBQUUscUNBQW9DeUIsR0FBRyxDQUFDQyxPQUFKLElBQWVELEdBQUksR0FBekQsQ0FBTDtBQUNBLFdBQU9PLEtBQVA7QUFDRDtBQUNGLEMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBLE1BQU1jLE1BQU0sR0FBR3VCLGdCQUFFbUMsUUFBRixDQUFXM0UsYUFBWCxFQUEwQixJQUExQixDQUFmOztlQUVleUIsUSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE5LiBOYXRhLUluZm9cbiAqIEBhdXRob3IgQW5kcmVpIFNhcmFrZWV2IDxhdnNAbmF0YS1pbmZvLnJ1PlxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBcIkBuYXRhXCIgcHJvamVjdC5cbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3XG4gKiB0aGUgRVVMQSBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTp2YXJpYWJsZS1uYW1lICovXG5pbXBvcnQgZGVidWdGYWN0b3J5IGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgZnMsIHsgU3RhdHMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBQYXRoUmVwb3J0ZXIgfSBmcm9tICdpby10cy9saWIvUGF0aFJlcG9ydGVyJztcbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFNlcmlhbFBvcnQgZnJvbSAnc2VyaWFscG9ydCc7XG5pbXBvcnQgdXNiRGV0ZWN0aW9uIGZyb20gJ3VzYi1kZXRlY3Rpb24nO1xuaW1wb3J0IHsgSU1pYkRlc2NyaXB0aW9uIH0gZnJvbSAnQG5hdGEvbmlidXMuanMtY2xpZW50L2xpYi9NaWJEZXNjcmlwdGlvbic7XG5pbXBvcnQge1xuICBDYXRlZ29yeSxcbiAgQ2F0ZWdvcnlWLFxuICBIZXhPck51bWJlcixcbiAgSUtub3duUG9ydCxcbiAgS25vd25Qb3J0Vixcbn0gZnJvbSAnQG5hdGEvbmlidXMuanMtY2xpZW50L2xpYi9zZXNzaW9uL0tub3duUG9ydHMnO1xuXG4vLyBsZXQgdXNiRGV0ZWN0aW9uOiB0eXBlb2YgVXNiRGV0ZWN0aW9uO1xuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ25pYnVzOmRldGVjdG9yJyk7XG5jb25zdCBkZXRlY3Rpb25QYXRoID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uL2RldGVjdGlvbi55bWwnKTtcbmxldCBrbm93blBvcnRzOiBQcm9taXNlPElLbm93blBvcnRbXT4gPSBQcm9taXNlLnJlc29sdmUoW10pO1xuXG5pbnRlcmZhY2UgSURldGVjdG9ySXRlbSB7XG4gIGRldmljZTogc3RyaW5nO1xuICB2aWQ6IEhleE9yTnVtYmVyO1xuICBwaWQ6IEhleE9yTnVtYmVyO1xuICBtYW51ZmFjdHVyZXI/OiBzdHJpbmc7XG4gIHNlcmlhbE51bWJlcj86IHN0cmluZztcbiAgY2F0ZWdvcnk6IENhdGVnb3J5O1xufVxuXG5pbnRlcmZhY2UgSURldGVjdGlvbiB7XG4gIG1pYkNhdGVnb3JpZXM6IHtcbiAgICBbY2F0ZWdvcnk6IHN0cmluZ106IElNaWJEZXNjcmlwdGlvbixcbiAgfTtcbiAga25vd25EZXZpY2VzOiBJRGV0ZWN0b3JJdGVtW107XG59XG5cbmNvbnN0IGxvYWREZXRlY3Rpb24gPSAoKTogSURldGVjdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhkZXRlY3Rpb25QYXRoLCAndXRmOCcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHlhbWwuc2FmZUxvYWQoZGF0YSkgYXMgSURldGVjdGlvbjtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQubWliQ2F0ZWdvcmllcykuZm9yRWFjaCgoY2F0ZWdvcnkpID0+IHtcbiAgICAgIGNvbnN0IGRlc2MgPSByZXN1bHQubWliQ2F0ZWdvcmllc1tjYXRlZ29yeV07XG4gICAgICBkZXNjLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXNjLnNlbGVjdCkpIHtcbiAgICAgICAgZGVzYy5zZWxlY3QgPSAoZGVzYy5zZWxlY3QgYXMgdW5rbm93biBhcyBzdHJpbmdbXSlcbiAgICAgICAgICAubWFwKGNhdCA9PiByZXN1bHQubWliQ2F0ZWdvcmllc1tjYXRdIHx8IGNhdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoYEVycm9yOiBmYWlsZWQgdG8gcmVhZCBmaWxlICR7ZGV0ZWN0aW9uUGF0aH0gKCR7ZXJyLm1lc3NhZ2V9KWApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbmxldCBkZXRlY3Rpb24gPSBsb2FkRGV0ZWN0aW9uKCk7XG5cbmZ1bmN0aW9uIHJlbG9hZERldmljZXMobGFzdEFkZGVkPzogdXNiRGV0ZWN0aW9uLklEZXZpY2UpIHtcbiAga25vd25Qb3J0cyA9IGtub3duUG9ydHMudGhlbihwb3J0cyA9PiByZWxvYWREZXZpY2VzQXN5bmMocG9ydHMsIGxhc3RBZGRlZCkpO1xufVxuXG5jb25zdCBkZXRlY3Rpb25MaXN0ZW5lciA9IChjdXJyOiBTdGF0cywgcHJldjogU3RhdHMpID0+IHtcbiAgaWYgKGN1cnIubXRpbWUgIT09IHByZXYubXRpbWUpIHtcbiAgICBkZWJ1ZyhgZGV0ZWN0aW9uIGZpbGUgd2FzIGNoYW5nZWQsIHJlbG9hZGluZyBkZXZpY2VzLi4uYCk7XG4gICAgZGV0ZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHJlbG9hZERldmljZXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZmlyZXMgYWRkXG4gKiBAZmlyZXMgcmVtb3ZlXG4gKiBAZmlyZXMgcGx1Z1xuICogQGZpcmVzIHVucGx1Z1xuICovXG5jbGFzcyBEZXRlY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHN0YXJ0KCkge1xuICAgIC8vIHVzYkRldGVjdGlvbiA9IHJlcXVpcmUoJ3VzYi1kZXRlY3Rpb24nKTtcbiAgICB1c2JEZXRlY3Rpb24uc3RhcnRNb25pdG9yaW5nKCk7XG4gICAgZGVidWcoYHN0YXJ0IHdhdGNoaW5nIHRoZSBkZXRlY3RvciBmaWxlICR7ZGV0ZWN0aW9uUGF0aH1gKTtcbiAgICBmcy53YXRjaEZpbGUoZGV0ZWN0aW9uUGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZXRlY3Rpb25MaXN0ZW5lcik7XG4gICAgLy8gZGV0ZWN0aW9uID0gbG9hZERldGVjdGlvbigpO1xuICAgIHJlbG9hZERldmljZXMoKTtcbiAgICAvLyDQlNC+0LvQttC90LAg0LHRi9GC0YwgZGVib3VuY2Ug0YEg0LfQsNC00LXRgNC20LrQvtC5LCDQuNC90LDRh9C1IFNlcmlhbC5saXN0INC90LUg0L7Qv9GA0LXQtNC10LvQuNGCXG4gICAgdXNiRGV0ZWN0aW9uLm9uKCdhZGQnLCByZWxvYWQpO1xuICAgIC8vINCj0LTQsNC70LXQvdC40LUg0LHQtdC3INC30LDQtNC10YDQttC60LghXG4gICAgdXNiRGV0ZWN0aW9uLm9uKCdyZW1vdmUnLCByZWxvYWREZXZpY2VzKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgZnMudW53YXRjaEZpbGUoZGV0ZWN0aW9uUGF0aCwgZGV0ZWN0aW9uTGlzdGVuZXIpO1xuICAgIHVzYkRldGVjdGlvbiAmJiB1c2JEZXRlY3Rpb24uc3RvcE1vbml0b3JpbmcoKTtcbiAgfVxuXG4gIHJlc3RhcnQoKSB7XG4gICAgaWYgKCF1c2JEZXRlY3Rpb24pIHJldHVybiB0aGlzLnN0YXJ0KCk7XG4gICAgdXNiRGV0ZWN0aW9uLnN0b3BNb25pdG9yaW5nKCk7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB1c2JEZXRlY3Rpb24uc3RhcnRNb25pdG9yaW5nKCkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UG9ydHMoKSB7XG4gICAgcmV0dXJuIGtub3duUG9ydHM7XG4gIH1cblxuICBnZXQgZGV0ZWN0aW9uKCk6IElEZXRlY3Rpb24gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBkZXRlY3Rpb247XG4gIH1cbn1cblxuY29uc3QgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoKTtcblxuLy8gaW50ZXJmYWNlIElTZXJpYWxQb3J0IHtcbi8vICAgY29tTmFtZTogc3RyaW5nO1xuLy8gICBsb2NhdGlvbklkPzogc3RyaW5nO1xuLy8gICBtYW51ZmFjdHVyZXI/OiBzdHJpbmc7XG4vLyAgIHBucElkPzogc3RyaW5nO1xuLy8gICBwcm9kdWN0SWQ6IEhleE9yTnVtYmVyO1xuLy8gICBzZXJpYWxOdW1iZXI6IHN0cmluZztcbi8vICAgdmVuZG9ySWQ6IEhleE9yTnVtYmVyO1xuLy8gfVxuXG4vLyB0eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pjtcbi8vXG4vLyBleHBvcnQgaW50ZXJmYWNlIElLbm93blBvcnQgZXh0ZW5kcyBPbWl0PFNlcmlhbFBvcnQuUG9ydEluZm8sICdwcm9kdWN0SWQnIHwgJ3ZlbmRvcklkJz4ge1xuLy8gICBkZXZpY2U/OiBzdHJpbmc7XG4vLyAgIHByb2R1Y3RJZDogbnVtYmVyO1xuLy8gICB2ZW5kb3JJZDogbnVtYmVyO1xuLy8gICBjYXRlZ29yeT86IHN0cmluZztcbi8vIH1cblxuY29uc3QgZ2V0SWQgPSAoaWQ/OiBIZXhPck51bWJlcikgPT4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KGlkLCAxNikgOiBpZDtcblxuZnVuY3Rpb24gZXF1YWxzKHBvcnQ6IFNlcmlhbFBvcnQuUG9ydEluZm8sIGRldmljZTogdXNiRGV0ZWN0aW9uLklEZXZpY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldElkKHBvcnQucHJvZHVjdElkKSA9PT0gZGV2aWNlLnByb2R1Y3RJZFxuICAgICYmIGdldElkKHBvcnQudmVuZG9ySWQpID09PSBkZXZpY2UudmVuZG9ySWRcbiAgICAmJiBwb3J0LnNlcmlhbE51bWJlciA9PT0gZGV2aWNlLnNlcmlhbE51bWJlcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0RGV2aWNlKHBvcnQ6IFNlcmlhbFBvcnQuUG9ydEluZm8sIGxhc3RBZGRlZD86IHVzYkRldGVjdGlvbi5JRGV2aWNlKVxuICA6IFByb21pc2U8SUtub3duUG9ydD4ge1xuICBsZXQgZGV0ZWN0ZWQ6IHVzYkRldGVjdGlvbi5JRGV2aWNlIHwgdW5kZWZpbmVkO1xuICBpZiAobGFzdEFkZGVkICYmIGVxdWFscyhwb3J0LCBsYXN0QWRkZWQpKSB7XG4gICAgZGV0ZWN0ZWQgPSBsYXN0QWRkZWQ7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGxpc3QgPSBhd2FpdCB1c2JEZXRlY3Rpb24uZmluZChnZXRJZChwb3J0LnZlbmRvcklkKSEsIGdldElkKHBvcnQucHJvZHVjdElkKSEsICgpID0+IHt9KTtcbiAgICBjb25zdCB7IHNlcmlhbE51bWJlciwgbWFudWZhY3R1cmVyIH0gPSBwb3J0O1xuICAgIGxpc3QgPSBfLmZpbHRlcihcbiAgICAgIGxpc3QsXG4gICAgICB7XG4gICAgICAgIHNlcmlhbE51bWJlcixcbiAgICAgICAgbWFudWZhY3R1cmVyLFxuICAgICAgfSxcbiAgICApO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWcoYFVua25vd24gZGV2aWNlICR7SlNPTi5zdHJpbmdpZnkocG9ydCl9YCk7XG4gICAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGRlYnVnKGBjYW4ndCBpZGVudGlmeSBkZXZpY2UgJHtKU09OLnN0cmluZ2lmeShwb3J0KX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgW2RldGVjdGVkXSA9IGxpc3Q7XG4gICAgfVxuICB9XG4gIGlmIChkZXRlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBwcm9kdWN0SWQsIHZlbmRvcklkLCBkZXZpY2VOYW1lOiBkZXZpY2UsIGRldmljZUFkZHJlc3MgfSA9IGRldGVjdGVkO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wb3J0LFxuICAgICAgcHJvZHVjdElkLFxuICAgICAgdmVuZG9ySWQsXG4gICAgICBkZXZpY2UsXG4gICAgICBkZXZpY2VBZGRyZXNzLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5wb3J0LFxuICAgIHByb2R1Y3RJZDogZ2V0SWQocG9ydC5wcm9kdWN0SWQpISxcbiAgICB2ZW5kb3JJZDogZ2V0SWQocG9ydC52ZW5kb3JJZCkhLFxuICB9O1xufVxuXG4vLyBjb25zdCBsb2FkRGV0ZWN0aW9uID0gKCkgPT4gbmV3IFByb21pc2U8SURldGVjdGlvbj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuLy8gICBmcy5yZWFkRmlsZShkZXRlY3Rpb25QYXRoLCAndXRmOCcsIChlcnIsIGRhdGEpID0+IHtcbi8vICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICByZWplY3QoYEVycm9yOiBmYWlsZWQgdG8gcmVhZCBmaWxlICR7ZGV0ZWN0aW9uUGF0aH0gKCR7ZXJyLm1lc3NhZ2V9KWApO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICBjb25zdCByZXN1bHQgPSB5YW1sLnNhZmVMb2FkKGRhdGEpIGFzIElEZXRlY3Rpb247XG4vLyAgICAgICBPYmplY3Qua2V5cyhyZXN1bHQubWliQ2F0ZWdvcmllcykuZm9yRWFjaCgoY2F0ZWdvcnkpID0+IHtcbi8vICAgICAgICAgcmVzdWx0Lm1pYkNhdGVnb3JpZXNbY2F0ZWdvcnldLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4vLyAgICAgICB9KTtcbi8vICAgICAgIHJlc29sdmUocmVzdWx0KTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy8gfSk7XG5cbmNvbnN0IG1hdGNoQ2F0ZWdvcnkgPSAocG9ydDogSUtub3duUG9ydCk6IENhdGVnb3J5ID0+IHtcbiAgY29uc3QgbWF0Y2ggPSBkZXRlY3Rpb24gJiYgXy5maW5kKFxuICAgIGRldGVjdGlvbiEua25vd25EZXZpY2VzLFxuICAgIGl0ZW0gPT4gKHBvcnQuZGV2aWNlICYmIHBvcnQuZGV2aWNlLnN0YXJ0c1dpdGgoaXRlbS5kZXZpY2UpKVxuICAgICAgJiYgKCFpdGVtLnNlcmlhbE51bWJlclxuICAgICAgICB8fCAocG9ydC5zZXJpYWxOdW1iZXIgJiYgcG9ydC5zZXJpYWxOdW1iZXIuc3RhcnRzV2l0aChpdGVtLnNlcmlhbE51bWJlcikpKVxuICAgICAgJiYgKCFpdGVtLm1hbnVmYWN0dXJlciB8fCAocG9ydC5tYW51ZmFjdHVyZXIgPT09IGl0ZW0ubWFudWZhY3R1cmVyKSlcbiAgICAgICYmIChnZXRJZChpdGVtLnZpZCkgPT09IHBvcnQudmVuZG9ySWQpICYmIChnZXRJZChpdGVtLnBpZCkgPT09IHBvcnQucHJvZHVjdElkKSxcbiAgKSBhcyBJRGV0ZWN0b3JJdGVtO1xuICBpZiAoIW1hdGNoICYmIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAmJiAocG9ydC5wcm9kdWN0SWQgPT09IDB4NjAwMSB8fCBwb3J0LnByb2R1Y3RJZCA9PT0gMHg2MDE1KVxuICAgICYmIHBvcnQudmVuZG9ySWQgPT09IDB4MDQwMykge1xuICAgIHJldHVybiAnZnRkaSc7XG4gIH1cbiAgaWYgKG1hdGNoKSByZXR1cm4gQ2F0ZWdvcnlWLmRlY29kZShtYXRjaC5jYXRlZ29yeSkuZ2V0T3JFbHNlKHVuZGVmaW5lZCk7XG59O1xuXG5hc3luYyBmdW5jdGlvbiByZWxvYWREZXZpY2VzQXN5bmMocHJldlBvcnRzOiBJS25vd25Qb3J0W10sIGxhc3RBZGRlZD86IHVzYkRldGVjdGlvbi5JRGV2aWNlKSB7XG4gIGNvbnN0IHBvcnRzOiBJS25vd25Qb3J0W10gPSBbXTtcbiAgdHJ5IHtcbiAgICBpZiAoZGV0ZWN0aW9uID09IG51bGwpIHtcbiAgICAgIGRldGVjdGlvbiA9IGxvYWREZXRlY3Rpb24oKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdDogU2VyaWFsUG9ydC5Qb3J0SW5mb1tdID0gYXdhaXQgU2VyaWFsUG9ydC5saXN0KCk7XG4gICAgY29uc3QgZXh0ZXJuYWxQb3J0cyA9IGxpc3QuZmlsdGVyKHBvcnQgPT4gISFwb3J0LnByb2R1Y3RJZCk7XG4gICAgLy8gY29uc3QgcHJldlBvcnRzID0ga25vd25Qb3J0cy5zcGxpY2UoMCk7XG5cbiAgICBhd2FpdCBleHRlcm5hbFBvcnRzLnJlZHVjZShhc3luYyAocHJvbWlzZSwgcG9ydCkgPT4ge1xuICAgICAgY29uc3QgbmV4dFBvcnRzID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgIGNvbnN0IHByZXYgPSBfLmZpbmRJbmRleChwcmV2UG9ydHMsIHsgY29tTmFtZTogcG9ydC5jb21OYW1lIH0pO1xuICAgICAgbGV0IGRldmljZTogSUtub3duUG9ydDtcbiAgICAgIGlmIChwcmV2ICE9PSAtMSkge1xuICAgICAgICBbZGV2aWNlXSA9IHByZXZQb3J0cy5zcGxpY2UocHJldiwgMSk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gbWF0Y2hDYXRlZ29yeShkZXZpY2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcnkgIT09IGRldmljZS5jYXRlZ29yeSkge1xuICAgICAgICAgIGRlYnVnKGBkZXZpY2UncyBjYXRlZ29yeSB3YXMgY2hhbmdlZCAke2RldmljZS5jYXRlZ29yeX0gdG8gJHtjYXRlZ29yeX1gKTtcbiAgICAgICAgICBkZXZpY2UuY2F0ZWdvcnkgJiYgZGV0ZWN0b3IuZW1pdCgncmVtb3ZlJywgZGV2aWNlKTtcbiAgICAgICAgICBkZXZpY2UuY2F0ZWdvcnkgPSBDYXRlZ29yeVYuZGVjb2RlKGNhdGVnb3J5KS5nZXRPckVsc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICBkZXZpY2UuY2F0ZWdvcnkgJiYgZGV0ZWN0b3IuZW1pdCgnYWRkJywgZGV2aWNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGV2aWNlID0gYXdhaXQgZGV0ZWN0RGV2aWNlKHBvcnQsIGxhc3RBZGRlZCk7XG4gICAgICAgIGRldmljZS5jYXRlZ29yeSA9IG1hdGNoQ2F0ZWdvcnkoZGV2aWNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5ldyBkZXZpY2UgcGx1Z2dlZFxuICAgICAgICAgKiBAZXZlbnQgRGV0ZWN0b3IjcGx1Z1xuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0b3IuZW1pdCgncGx1ZycsIGRldmljZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQT1JUJywgSlNPTi5zdHJpbmdpZnkocG9ydCkpO1xuICAgICAgICBpZiAoZGV2aWNlLmNhdGVnb3J5KSB7XG4gICAgICAgICAgZGVidWcoYG5ldyBkZXZpY2UgJHtkZXZpY2UuZGV2aWNlIHx8IGRldmljZS52ZW5kb3JJZH0vXFxcbiR7ZGV2aWNlLmNhdGVnb3J5fSB3YXMgcGx1Z2dlZCB0byAke2RldmljZS5jb21OYW1lfWApO1xuICAgICAgICAgIGRldGVjdG9yLmVtaXQoJ2FkZCcsIGRldmljZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3Vua25vd24gZGV2aWNlICVvIHdhcyBwbHVnZ2VkJywgZGV2aWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IEtub3duUG9ydFYuZGVjb2RlKGRldmljZSk7XG4gICAgICBpZiAodmFsaWRhdGlvbi5pc0xlZnQoKSkge1xuICAgICAgICBkZWJ1ZygnPGVycm9yPicsIFBhdGhSZXBvcnRlci5yZXBvcnQodmFsaWRhdGlvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFBvcnRzLnB1c2godmFsaWRhdGlvbi52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dFBvcnRzO1xuICAgIH0sIFByb21pc2UucmVzb2x2ZShwb3J0cykpO1xuICAgIHByZXZQb3J0cy5mb3JFYWNoKChwb3J0KSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBEZXRlY3RvciN1bnBsdWdcbiAgICAgICAqL1xuICAgICAgZGV0ZWN0b3IuZW1pdCgndW5wbHVnJywgcG9ydCk7XG4gICAgICBkZWJ1ZyhgZGV2aWNlICR7cG9ydC5kZXZpY2UgfHwgcG9ydC52ZW5kb3JJZH0vXFxcbiR7cG9ydC5jYXRlZ29yeSB8fCBwb3J0LnByb2R1Y3RJZH0gd2FzIHVucGx1Z2dlZCBmcm9tICR7cG9ydC5jb21OYW1lfWApO1xuICAgICAgLyoqXG4gICAgICAgKiBkZXZpY2Ugd2l0aCBjYXRlZ29yeSB3YXMgcmVtb3ZlZFxuICAgICAgICogQGV2ZW50IERldGVjdG9yI3JlbW92ZVxuICAgICAgICogQHBhcmFtIHtJS25vd25Qb3J0fSBkZXZpY2VcbiAgICAgICAqL1xuICAgICAgcG9ydC5jYXRlZ29yeSAmJiBkZXRlY3Rvci5lbWl0KCdyZW1vdmUnLCBwb3J0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9ydHM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlYnVnKGBFcnJvcjogcmVsb2FkIGRldmljZXMgd2FzIGZhaWxlZCAoJHtlcnIubWVzc2FnZSB8fCBlcnJ9KWApO1xuICAgIHJldHVybiBwb3J0cztcbiAgfVxufVxuXG4vLyBkZWJ1Zyhgc3RhcnQgd2F0Y2hpbmcgdGhlIGRldGVjdG9yIGZpbGUgJHtkZXRlY3Rpb25QYXRofWApO1xuLy8gZnMud2F0Y2hGaWxlKGRldGVjdGlvblBhdGgsIHsgcGVyc2lzdGVudDogZmFsc2UgfSwgKGN1cnIsIHByZXYpID0+IHtcbi8vICAgaWYgKGN1cnIubXRpbWUgIT09IHByZXYubXRpbWUpIHtcbi8vICAgICBkZWJ1ZyhgZGV0ZWN0aW9uIGZpbGUgd2FzIGNoYW5nZWQsIHJlbG9hZGluZyBkZXZpY2VzLi4uYCk7XG4vLyAgICAgZGV0ZWN0aW9uID0gdW5kZWZpbmVkO1xuLy8gICAgIHJlbG9hZERldmljZXMoKS5jYXRjaCgpO1xuLy8gICB9XG4vLyB9KTtcblxuLy8gcmVsb2FkRGV2aWNlcygpO1xuXG5jb25zdCByZWxvYWQgPSBfLmRlYm91bmNlKHJlbG9hZERldmljZXMsIDIwMDApO1xuXG5leHBvcnQgZGVmYXVsdCBkZXRlY3RvcjtcbiJdfQ==